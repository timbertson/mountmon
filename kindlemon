#!/usr/bin/env python

import dbus
import gobject
import time
import sys
import subprocess

import logging
LOG_FILE = '/tmp/kindlemon.log'
logging.basicConfig(filename=LOG_FILE, level=logging.DEBUG)
debug = logging.debug
puts = logging.info

class Monitor():
	HAL = "org.freedesktop.Hal"
	def __init__(self, **kwargs):
		self.command_mappings = kwargs
		for item, cmd in self.command_mappings.items():
			puts("for %r: run %s" % (item, cmd))
		self.bus = dbus.SystemBus()
		self.hal_manager = self.bus.get_object(self.HAL, "/org/freedesktop/Hal/Manager")
		self.hal_service = dbus.Interface(self.hal_manager, self.HAL + ".Manager")

		self.bus.add_signal_receiver(self.gdl_added,
			"DeviceAdded",
			self.HAL + ".Manager",
			self.HAL,
			"/org/freedesktop/Hal/Manager")

		for device_udi in self.hal_service.FindDeviceByCapability("volume"):
			self.device_added(device_udi)

	def gdl_added(self, device_udi):
		"""This method is called when a HAL device is added"""
		puts("device added: %r" % (device_udi,))
		self.device_added(device_udi)

	def device_added(self, device_udi):
		mount_point = None
		device_name = None
		try:
			for attempts in range(0,5):
				device = self.bus.get_object(self.HAL, device_udi)
				properties = device.GetAllProperties(dbus_interface="org.freedesktop.Hal.Device")
				device_name = properties['info.product']
				if not device_name in self.command_mappings:
					debug("'%s' is not in %r - ignoring" % (device_name, self.command_mappings.keys()))
					return
				if not properties['volume.is_mounted']:
					if attempts == 4:
						logging.warn("timed out waiting for mount")
						return
					time.sleep(1)
				else:
					mount_point = properties['volume.mount_point']
					break
		except KeyError, e:
			debug("device has no such key: %s" % (e,))
			return

		self.run_command(self.command_mappings[device_name], mount_point)
	
	def run_command(self, cmd, mount_point):
		debug("running command: %s %s" % (cmd, mount_point))
		proc = subprocess.Popen(cmd + [mount_point], stdout = subprocess.PIPE, stderr = subprocess.PIPE)
		retcode = proc.wait()
		puts("Command `%s` finshed with exit code %s" % (cmd, retcode))
		_out, _err = proc.stdout.read(), proc.stderr.read()
		if _out:
			debug("Command output:\n%s" % (_out,))
		if _err and retcode != 0:
			debug("Command ERROR output:\n%s" % (_err,))

def run(cmd):
	from dbus.mainloop.glib import DBusGMainLoop
	DBusGMainLoop(set_as_default=True)
	monitor = Monitor(Kindle=cmd)
	loop = gobject.MainLoop()
	try:
		loop.run()
	except (KeyboardInterrupt, EOFError):
		loop.quit()

def main():
	cmd_parts = sys.argv[1:]
	if not cmd_parts:
		print >> sys.stderr, "Usage: %s [-v] <command>" % (sys.argv[0],)
		return 1
	if cmd_parts[0] == '-v':
		DEBUG = True
		cmd_parts.pop(0)
	run(cmd_parts)

if __name__ == '__main__':
	sys.exit(main())
